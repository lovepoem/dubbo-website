<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="Dubbo-supporting-gRPC-HTTP2-and-protobuf" />
	<meta name="description" content="Dubbo-supporting-gRPC-HTTP2-and-protobuf" />
	<!-- 网页标签标题 -->
	<title>Dubbo-supporting-gRPC-HTTP2-and-protobuf</title>
	<link rel="shortcut icon" href="/img/dubbo.ico"/>
	<link rel="stylesheet" href="/build/blogDetail.css" />
</head>
<body>
	<div id="root"><div class="blog-detail-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/dubbo_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html">首页</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/docs/user/quick-start.html">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/docs/developers/developers_dev.html">开发者</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/blog/index.html">博客</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html">社区</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/ecology/index.html">生态系统</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/download.html">下载</a></li></ul></div></div></header><section class="blog-content markdown-body"><h1>Dubbo 在跨语言和协议穿透性方向上的探索：支持 HTTP/2 gRPC 和 Protobuf</h1>
<p>本文整理自刘军在 Dubbo 成都 meetup 上分享的《Dubbo 在多语言和协议穿透性方向上的探索》。</p>
<p>本文总体上可分为基础产品简介、Dubbo 对 gRPC (HTTP/2) 和 Protobuf 的支持及示例演示三部分，在简介部分介绍了 Dubbo、HTTP/2、gRPC、Protobuf 的基本概念和特点；第二部分介绍了 Dubbo 为何要支持 gRPC (HTTP/2) 和 Protobuf，以及这种支持为 gRPC 和 Dubbo 开发带来的好处与不同；第三部分通过两个实例分别演示了 Dubbo gRPC 和 Dubbo Protobuf 的使用方式。</p>
<h2>基本介绍</h2>
<h3>Dubbo 协议</h3>
<p>从协议层面展开，以下是当前 2.7 版本支持的 Dubbo 协议</p>
<p><img src="img/blog/grpc/dubbo-ptotocol.png" alt="image-20191029103919557"></p>
<p>众所周知，Dubbo 协议是直接定义在 TCP 传输层协议之上，由于 TCP 高可靠全双工的特点，为 Dubbo 协议的定义提供了最大的灵活性，但同时也正是因为这样的灵活性，RPC 协议普遍都是定制化的私有协议，Dubbo 同样也面临这个问题。在这里我们着重讲一下 Dubbo 在协议通用性方面值得改进的地方，关于协议详细解析请参见<a href="http://dubbo.apache.org/zh-cn/blog/dubbo-protocol.html">官网博客</a></p>
<ul>
<li>Dubbo 协议体 Body 中有一个可扩展的 attachments 部分，这给 RPC 方法之外额外传递附加属性提供了可能，是一个很好的设计。但是类似的 Header 部分，却缺少类似的可扩展 attachments，这点可参考 HTTP 定义的 Ascii Header 设计，将 Body Attachments 和 Header Attachments 做职责划分。</li>
<li>Body 协议体中的一些 RPC 请求定位符如 Service Name、Method Name、Version 等，可以提到 Header 中，和具体的序列化协议解耦，以更好的被网络基础设施识别或用于流量管控。</li>
<li>扩展性不够好，欠缺协议升级方面的设计，如 Header 头中没有预留的状态标识位，或者像 HTTP 有专为协议升级或协商设计的特殊 packet。</li>
<li>在 Java 版本的代码实现上，不够精简和通用。如在链路传输中，存在一些语言绑定的内容；消息体中存在冗余内容，如 Service Name 在 Body 和 Attachments 中都存在。</li>
</ul>
<h3>HTTP/1</h3>
<p>相比于直接构建与 TPC 传输层的私有 RPC 协议，构建于 HTTP 之上的远程调用解决方案会有更好的通用性，如WebServices 或 REST 架构，使用 HTTP + JSON 可以说是一个事实标准的解决方案。</p>
<p>之所有选择构建在 HTTP 之上，我认为有两个最大的优势：</p>
<ol>
<li>HTTP 的语义和可扩展性能很好的满足 RPC 调用需求。</li>
<li>通用性，HTTP 协议几乎被网络上的所有设备所支持，具有很好的协议穿透性。</li>
</ol>
<p><img src="../../img/blog/grpc/http1.png" alt="image-20191029113404906"></p>
<p>具体来说，HTTP/1 的优势和限制是：</p>
<ul>
<li>
<p>典型的 Request – Response 模型，一个链路上一次只能有一个等待的 Request 请求</p>
</li>
<li>
<p>HTTP/1 支持 Keep-Alive 链接，避免了链接重复创建开销</p>
</li>
<li>
<p>Human Readable Headers，使用更通用、更易于人类阅读的头部传输格式</p>
</li>
<li>
<p>无直接 Server Push 支持，需要使用 Polling Long-Polling 等变通模式</p>
</li>
</ul>
<h3>HTTP/2</h3>
<p>HTTP/2 保留了 HTTP/1 的所有语义，在保持兼容的同时，在通信模型和传输效率上做了很大的改进。</p>
<p><img src="../../img/blog/grpc/http2.png" alt="image-20191029113416731"></p>
<ul>
<li>
<p>支持单条链路上的 Multiplexing，相比于 Request - Response 独占链路，基于 Frame 实现更高效利用链路</p>
</li>
<li>
<p>Request - Stream 语义，原生支持 Server Push 和 Stream 数据传输</p>
</li>
<li>
<p>Flow Control，单条 Stream 粒度的和整个链路粒度的流量控制</p>
</li>
<li>
<p>头部压缩 HPACK</p>
</li>
<li>
<p>Binary Frame</p>
</li>
<li>
<p>原生 TLS 支持</p>
</li>
</ul>
<h3>gRPC</h3>
<p>上面提到了在 HTTP 及 TCP 协议之上构建 RPC 协议各自的优缺点，相比于 Dubbo 构建于 TPC 传输层之上，Google 选择将 gRPC 直接定义在 HTTP/2 协议之上，关于 gRPC 的 [基本介绍](<a href="https://platformlab.stanford.edu/Seminar">https://platformlab.stanford.edu/Seminar</a> Talks/gRPC.pdf)和 <a href="https://grpc.io/blog/principles/?spm=ata.13261165.0.0.2be55017XbUhs8">设计愿景</a> 请参考以上两篇文章，我这里仅摘取 设计愿景 中几个能反映 gRPC 设计目的特性来做简单说明。</p>
<ul>
<li>
<p>Coverage &amp; Simplicity，协议设计和框架实现要足够通用和简单，能运行在任何设备之上，甚至一些资源首先的如 IoT、Mobile 等设备。</p>
</li>
<li>
<p>Interoperability &amp; Reach，要构建在更通用的协议之上，协议本身要能被网络上几乎所有的基础设施所支持。</p>
</li>
<li>
<p>General Purpose &amp; Performant，要在场景和性能间做好平衡，首先协议本身要是适用于各种场景的，同时也要尽量有高的性能。</p>
</li>
<li>
<p>Payload Agnostic，协议上传输的负载要保持语言和平台中立。</p>
</li>
<li>
<p>Streaming，要支持 Request - Response、Request - Stream、Bi-Steam 等通信模型。</p>
</li>
<li>
<p>Flow Control，协议自身具备流量感知和限制的能力。</p>
</li>
<li>
<p>Metadata Exchange，在 RPC 服务定义之外，提供额外附加数据传输的能力。</p>
</li>
</ul>
<p>总的来说，在这样的设计理念指导下，gRPC 最终被设计为一个跨语言、跨平台的、通用的、高性能的、基于 HTTP/2 的 RPC 协议和框架。</p>
<h3>Protobuf</h3>
<p><a href="https://developers.google.com/protocol-buffers/docs/overview">Protocol buffers (Protobuf)</a> 是 Google 推出的一个跨平台、语言中立的结构化数据描述和序列化的产品，它定义了一套结构化数据定义的协议，同时也提供了相应的 <a href="https://github.com/protocolbuffers/protobuf/releases/tag/v3.10.0">Compiler</a> 工具，用来将语言中立的描述转化为相应语言的具体描述。</p>
<p>它的一些特性包括：</p>
<ul>
<li>
<p>跨语言 跨平台，语言中立的数据描述格式，默认提供了生成多种语言的 Compiler 工具。</p>
</li>
<li>
<p>安全性，由于反序列化的范围和输出内容格式都是 Compiler 在编译时预生成的，因此绕过了类似 Java Deserialization Vulnarability 的问题。</p>
</li>
<li>
<p>二进制 高性能</p>
</li>
<li>
<p>强类型</p>
</li>
<li>
<p>字段变更向后兼容</p>
</li>
</ul>
<pre><code class="language-idl">message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4;
}
</code></pre>
<p>除了结构化数据描述之外，Protobuf 还支持定义 RPC 服务，它允许我们定义一个 <code>.proto</code> 的服务描述文件，进而利用 Protobuf Compiler 工具生成特定语言和 RPC 框架的接口和 stub。后续将要具体讲到的 gRPC + Protobuf、Dubbo-gRPC + Protobuf 以及 Dubbo + Protobuf 都是通过定制 Compiler 类实现的。</p>
<pre><code class="language-idl">service SearchService {
 rpc Search (SearchRequest) returns (SearchResponse);
}
</code></pre>
<h2>Dubbo 所做的支持</h2>
<p>跨语言的服务开发涉及到多个方面，从服务定义、RPC 协议到序列化协议都要做到语言中立，同时还针对每种语言有对应的 SDK 实现。虽然得益于社区的贡献，现在 Dubbo 在多语言 SDK 实现上逐步有了起色，已经提供了包括 Java, Go, PHP, C#, Python, NodeJs, C 等版本的客户端或全量实现版本，但在以上提到的跨语言友好型方面，以上三点还是有很多可改进之处。</p>
<ul>
<li>
<p>协议，上面我们已经分析过 Dubbo 协议既有的缺点，如果能在 HTTP/2 之上构建应用层协议，则无疑能避免这些弊端，同时最大可能的提高协议的穿透性，避免网关等协议转换组件的存在，更有利于链路上的流量管控。考虑到 gRPC 是构建在 HTTP/2 之上，并且已经是云原生领域推荐的通信协议，Dubbo 在第一阶段选择了直接支持 gRPC 协议作为当前的 HTTP/2 解决方案。我们也知道 gRPC 框架自身的弊端在于易用性不足以及服务治理能力欠缺（这也是目前绝大多数厂商不会直接裸用 gRPC 框架的原因），通过将其集成进 Dubbo 框架，用户可以方便的使用 Dubbo 编程模型 + Dubbo 服务治理 + gRPC 协议通信的组合。</p>
</li>
<li>
<p>服务定义，当前 Dubbo 的服务定义和具体的编程语言绑定，没有提供一种语言中立的服务描述格式，比如 Java 就是定义 Interface 接口，到了其他语言又得重新以另外的格式定义一遍。因此 Dubbo 通过支持 Protobuf 实现了语言中立的服务定义。</p>
</li>
<li>
<p>序列化，Dubbo 当前支持的序列化包括 Json、Hessian2、Kryo、FST、Java 等，而这其中支持跨语言的只有 Json、Hessian2，通用的 Json 有固有的性能问题，而 Hessian2 无论在效率还是多语言 SDK 方面都有所欠缺。为此，Dubbo 通过支持 Protobuf 序列化来提供更高效、易用的跨语言序列化方案。</p>
</li>
</ul>
<h2>示例</h2>
<h3>示例 1，使用 Dubbo 开发 gRPC 服务</h3>
<p><a href="https://grpc.io/">gRPC</a> 是 Google 开源的构建在 HTTP/2 之上的一个 PRC 通信协议。Dubbo 依赖其灵活的协议扩展机制，增加了对 gRPC (HTTP/2) 协议的支持。</p>
<p>目前的支持限定在 Dubbo Java 语言版本，后续 Go 语言或其他语言版本将会以类似方式提供支持。下面，通过一个<a href="https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-grpc">简单的示例</a>来演示如何在 Dubbo 中使用 gRPC 协议通信。</p>
<h4>1. 定义服务 IDL</h4>
<p>首先，通过标准的 Protobuf 协议定义服务如下：</p>
<pre><code class="language-idl">syntax = &quot;proto3&quot;;

option java_multiple_files = true;
option java_package = &quot;io.grpc.examples.helloworld&quot;;
option java_outer_classname = &quot;HelloWorldProto&quot;;
option objc_class_prefix = &quot;HLW&quot;;

package helloworld;

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}

</code></pre>
<p>在此，我们定义了一个只有一个方法 sayHello 的 Greeter 服务，同时定义了方法的入参和出参，</p>
<h4>2. PCompiler 生成 Stub</h4>
<ol>
<li>定义 Maven Protobuf Compiler 插件工具。这里我们扩展了 Protobuf 的 Compiler 工具，以用来生成 Dubbo 特有的 RPC stub，此当前以 Maven 插件的形式发布。</li>
</ol>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.7.1:exe:${os.detected.classifier}	
    <span class="hljs-tag">&lt;/<span class="hljs-name">protocArtifact</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pluginId</span>&gt;</span>dubbo-grpc-java<span class="hljs-tag">&lt;/<span class="hljs-name">pluginId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pluginArtifact</span>&gt;</span>org.apache.dubbo:protoc-gen-dubbo-java:1.19.0-SNAPSHOT:exe:${os.detected.classifier}<span class="hljs-tag">&lt;/<span class="hljs-name">pluginArtifact</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>&gt;</span>build/generated/source/proto/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">outputDirectory</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">clearOutputDirectory</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">clearOutputDirectory</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pluginParameter</span>&gt;</span>grpc<span class="hljs-tag">&lt;/<span class="hljs-name">pluginParameter</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile-custom<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
</code></pre>
<p>其中，</p>
<p>pluginArtifact 指定了 Dubbo 定制版本的 Java Protobuf Compiler 插件，通过这个插件来在编译过程中生成 Dubbo 定制版本的 gRPC stub。</p>
<pre><code class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">pluginArtifact</span>&gt;</span>org.apache.dubbo:protoc-gen-dubbo-java:1.19.0-SNAPSHOT:exe:${os.detected.classifier}<span class="hljs-tag">&lt;/<span class="hljs-name">pluginArtifact</span>&gt;</span>
</code></pre>
<p>由于 <code>protoc-gen-dubbo-java</code> 支持 gRPC 和 Dubbo 两种协议，可生成的 stub 类型，默认值是 gRPC，关于 dubbo 协议的使用可参见 <a href="">使用 Protobuf 开发 Dubbo 服务</a>。</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">pluginParameter</span>&gt;</span>grpc<span class="hljs-tag">&lt;/<span class="hljs-name">pluginParameter</span>&gt;</span>
</code></pre>
<ol start="2">
<li>
<p>生成 Java Bean 和 Dubbo-gRPC stub</p>
<pre><code class="language-sh"><span class="hljs-comment"># 运行以下 maven 命令</span>
$ mvn clean compile
</code></pre>
<p>生成的 Stub 和消息类 如下：
<img src="../../img/blog/grpc/compiler-classes.png" alt="image-20191026130516896"></p>
<p>重点关注 GreeterGrpc ，包含了所有 gRPC 标准的 stub 类/方法，同时增加了 Dubbo 特定的接口，之后 Provider 端的服务暴露和 Consumer 端的服务调用都将依赖这个接口。</p>
<pre><code class="language-java"><span class="hljs-comment">/**
 * Code generated for Dubbo
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IGreeter</span> </span>{

<span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> io.grpc.examples.helloworld.<span class="hljs-function">HelloReply 	<span class="hljs-title">sayHello</span><span class="hljs-params">(io.grpc.examples.helloworld.HelloRequest request)</span> </span>{
   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"No need to override this method, extend XxxImplBase and override all methods it allows."</span>);
}

<span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> com.google.common.util.concurrent.ListenableFuture&lt;io.grpc.examples.helloworld.HelloReply&gt; sayHelloAsync(
    io.grpc.examples.helloworld.HelloRequest request) {
   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"No need to override this method, extend XxxImplBase and override all methods it allows."</span>);
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(io.grpc.examples.helloworld.HelloRequest request,
    io.grpc.stub.StreamObserver&lt;io.grpc.examples.helloworld.HelloReply&gt; responseObserver)</span></span>;

}
</code></pre>
</li>
</ol>
<h4>3. 业务逻辑开发</h4>
<p>继承 <code>GreeterGrpc.GreeterImplBase</code> （来自第 2 步），编写业务逻辑，这点和原生 gRPC 是一致的。</p>
<pre><code class="language-java"><span class="hljs-keyword">package</span> org.apache.dubbo.samples.basic.impl;

<span class="hljs-keyword">import</span> io.grpc.examples.helloworld.GreeterGrpc;
<span class="hljs-keyword">import</span> io.grpc.examples.helloworld.HelloReply;
<span class="hljs-keyword">import</span> io.grpc.examples.helloworld.HelloRequest;
<span class="hljs-keyword">import</span> io.grpc.stub.StreamObserver;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GrpcGreeterImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GreeterGrpc</span>.<span class="hljs-title">GreeterImplBase</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver)</span> 		</span>{
        System.out.println(<span class="hljs-string">"Received request from client."</span>);
        System.out.println(<span class="hljs-string">"Executing thread is "</span> + Thread.currentThread().getName());
        HelloReply reply = HelloReply.newBuilder()
          .setMessage(<span class="hljs-string">"Hello "</span> + 	request.getName()).build();
        responseObserver.onNext(reply);
        responseObserver.onCompleted();
    }
}
</code></pre>
<h4>4. Provider 端暴露 Dubbo 服务</h4>
<p>以 Spring XML 为例</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"demo-provider"</span>/&gt;</span>

<span class="hljs-comment">&lt;!-- 指定服务暴露协议为 gRPC --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"grpc"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"grpc"</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">"zookeeper://${zookeeper.address:127.0.0.1}:2181"</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"greeter"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.dubbo.samples.basic.impl.GrpcGreeterImpl"</span>/&gt;</span>

<span class="hljs-comment">&lt;!-- 指定 protoc-gen-dubbo-java 生成的接口 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"io.grpc.examples.helloworld.GreeterGrpc$IGreeter"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"greeter"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"grpc"</span>/&gt;</span>
</code></pre>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{
  ClassPathXmlApplicationContext context =
    <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"spring/dubbo-demo-provider.xml"</span>);
  context.start();

  System.out.println(<span class="hljs-string">"dubbo service started"</span>);
  <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>).await();
}
</code></pre>
<h4>5. 引用 Dubbo 服务</h4>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"demo-consumer"</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">"zookeeper://${zookeeper.address:127.0.0.1}:2181"</span>/&gt;</span>

<span class="hljs-comment">&lt;!-- 指定 protoc-gen-dubbo-java 生成的接口 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"greeter"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"io.grpc.examples.helloworld.GreeterGrpc$IGreeter"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"grpc"</span>/&gt;</span>
</code></pre>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{
  ClassPathXmlApplicationContext context =
    <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"spring/dubbo-demo-consumer.xml"</span>);
  context.start();

  GreeterGrpc.IGreeter greeter = (GreeterGrpc.IGreeter) context.getBean(<span class="hljs-string">"greeter"</span>);

  HelloReply reply = greeter.sayHello(HelloRequest.newBuilder().setName(<span class="hljs-string">"world!"</span>).build());
  System.out.println(<span class="hljs-string">"Result: "</span> + reply.getMessage());

  System.in.read();
}
</code></pre>
<h4>示例1附：高级用法</h4>
<p><strong>一、异步调用</strong></p>
<p>再来看一遍 <code>protoc-gen-dubbo-java</code> 生成的接口：</p>
<pre><code class="language-java"><span class="hljs-comment">/**
 * Code generated for Dubbo
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IGreeter</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> HelloReply <span class="hljs-title">sayHello</span><span class="hljs-params">(HelloRequest request)</span> </span>{
     <span class="hljs-comment">// ......</span>
  }
  <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">public</span> ListenableFuture&lt;HelloReply&gt; <span class="hljs-title">sayHelloAsync</span><span class="hljs-params">(HelloRequest request)</span> </span>{
     <span class="hljs-comment">// ......</span>
  }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver)</span></span>;
}
</code></pre>
<p>这里为 sayHello 方法生成了三种类型的重载方法，分别用于同步调用、异步调用和流式调用，如果消费端要进行异步调用，直接调用 sayHelloAsync() 即可：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>{
	<span class="hljs-comment">// ...</span>
  GreeterGrpc.IGreeter greeter = (GreeterGrpc.IGreeter) context.getBean(<span class="hljs-string">"greeter"</span>);
  ListenableFuture&lt;HelloReply&gt; future =   
        greeter.sayHAsyncello(HelloRequest.newBuilder().setName(<span class="hljs-string">"world!"</span>).build());
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><strong>二、高级配置</strong></p>
<p>由于当前实现方式是直接集成了 gRPC-java SDK，因此很多配置还没有和 Dubbo 侧对齐，或者还没有以 Dubbo 的配置形式开放，因此，为了提供最大的灵活性，我们直接把 gRPC-java 的配置接口暴露了出来。</p>
<p>绝大多数场景下，你可能并不会用到以下扩展，因为它们更多的是对 gRPC 协议的拦截或者 HTTP/2 层面的配置。同时使用这些扩展点可能需要对 HTTP/2 或 gRPC 有基本的了解。</p>
<p><strong>扩展点</strong></p>
<p>目前支持的扩展点如下：</p>
<ul>
<li>
<p>org.apache.dubbo.rpc.protocol.grpc.interceptors.ClientInterceptor</p>
</li>
<li>
<p>org.apache.dubbo.rpc.protocol.grpc.interceptors.GrpcConfigurator</p>
</li>
<li>
<p>org.apache.dubbo.rpc.protocol.grpc.interceptors.ServerInterceptor</p>
</li>
<li>
<p>org.apache.dubbo.rpc.protocol.grpc.interceptors.ServerTransportFilter</p>
</li>
</ul>
<p>GrpcConfigurator 是最通用的扩展点，我们以此为例来说明一下，其基本定义如下：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GrpcConfigurator</span> </span>{
    <span class="hljs-comment">// 用来定制 gRPC NettyServerBuilder</span>
    <span class="hljs-function"><span class="hljs-keyword">default</span> NettyServerBuilder <span class="hljs-title">configureServerBuilder</span><span class="hljs-params">(NettyServerBuilder builder, URL url)</span> </span>{
        <span class="hljs-keyword">return</span> builder;
    }
    <span class="hljs-comment">// 用来定制 gRPC NettyChannelBuilder</span>
    <span class="hljs-function"><span class="hljs-keyword">default</span> NettyChannelBuilder <span class="hljs-title">configureChannelBuilder</span><span class="hljs-params">(NettyChannelBuilder builder, URL url)</span> </span>{
        <span class="hljs-keyword">return</span> builder;
    }
    <span class="hljs-comment">// 用来定制 gRPC CallOptions, 定义某个服务在每次请求间传递数据</span>
    <span class="hljs-function"><span class="hljs-keyword">default</span> CallOptions <span class="hljs-title">configureCallOptions</span><span class="hljs-params">(CallOptions options, URL url)</span> </span>{
        <span class="hljs-keyword">return</span> options;
    }
}
</code></pre>
<p>以下是一个示例扩展实现：</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGrpcConfigurator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GrpcConfigurator</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExecutorService executor = Executors
            .newFixedThreadPool(<span class="hljs-number">200</span>, <span class="hljs-keyword">new</span> NamedThreadFactory(<span class="hljs-string">"Customized-grpc"</span>, <span class="hljs-keyword">true</span>));

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> NettyServerBuilder <span class="hljs-title">configureServerBuilder</span><span class="hljs-params">(NettyServerBuilder builder, URL url)</span> </span>{
        <span class="hljs-keyword">return</span> builder.executor(executor);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> NettyChannelBuilder <span class="hljs-title">configureChannelBuilder</span><span class="hljs-params">(NettyChannelBuilder builder, URL url)</span>
    </span>{
        <span class="hljs-keyword">return</span> builder.flowControlWindow(<span class="hljs-number">10</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CallOptions <span class="hljs-title">configureCallOptions</span><span class="hljs-params">(CallOptions options, URL url)</span> </span>{
        <span class="hljs-keyword">return</span> options.withOption(CallOptions.Key.create(<span class="hljs-string">"key"</span>), <span class="hljs-string">"value"</span>);
    }
}

</code></pre>
<p>配置为 Dubbo SPI，`resources/META-INF/services 增加配置文件</p>
<pre><code class="language-properties"><span class="hljs-attr">default</span>=<span class="hljs-string">org.apache.dubbo.samples.basic.comtomize.MyGrpcConfigurator</span>
</code></pre>
<ol>
<li>
<p>指定 Provider 端线程池</p>
<p>默认用的是 Dubbo 的线程池，有 fixed (默认)、cached、direct 等类型。以下演示了切换为业务自定义线程池。</p>
<pre><code class="language-java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExecutorService executor = Executors
      .newFixedThreadPool(<span class="hljs-number">200</span>, <span class="hljs-keyword">new</span> NamedThreadFactory(<span class="hljs-string">"Customized-grpc"</span>, <span class="hljs-keyword">true</span>));

<span class="hljs-function"><span class="hljs-keyword">public</span> NettyServerBuilder <span class="hljs-title">configureServerBuilder</span><span class="hljs-params">(NettyServerBuilder builder, URL url)</span> 
</span>{
  <span class="hljs-keyword">return</span> builder.executor(executor);
}

</code></pre>
</li>
<li>
<p>指定 Consumer 端限流值</p>
<p>设置 Consumer 限流值为 10</p>
<pre><code class="language-java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> NettyChannelBuilder <span class="hljs-title">configureChannelBuilder</span><span class="hljs-params">(NettyChannelBuilder builder, URL url)</span>
</span>{
  <span class="hljs-keyword">return</span> builder.flowControlWindow(<span class="hljs-number">10</span>);
}

</code></pre>
</li>
<li>
<p>传递附加参数</p>
<p>DemoService 服务调用传递 key</p>
<pre><code class="language-java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> CallOptions <span class="hljs-title">configureCallOptions</span><span class="hljs-params">(CallOptions options, URL url)</span> </span>{
  <span class="hljs-keyword">if</span> (url.getServiceInterface().equals(<span class="hljs-string">"xxx.DemoService"</span>)) {
    <span class="hljs-keyword">return</span> options.withOption(CallOptions.Key.create(<span class="hljs-string">"key"</span>), <span class="hljs-string">"value"</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> options;
  }
}

</code></pre>
</li>
</ol>
<p><strong>三、TLS 配置</strong></p>
<p>配置方式和 Dubbo 提供的通用的 <a href="">TLS 支持</a>一致，具体请参见文档</p>
<h3>示例 2， 使用 Protobuf 开发 Dubbo 服务</h3>
<p>下面，我们以一个<a href="https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-protobuf">具体的示例</a>来看一下基于 Protobuf 的 Dubbo 服务开发流程。</p>
<h4>1. 定义服务</h4>
<p>通过标准 Protobuf 定义服务</p>
<pre><code class="language-idl">syntax = &quot;proto3&quot;;

option java_multiple_files = true;
option java_package = &quot;org.apache.dubbo.demo&quot;;
option java_outer_classname = &quot;DemoServiceProto&quot;;
option objc_class_prefix = &quot;DEMOSRV&quot;;

package demoservice;

// The demo service definition.
service DemoService {
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}

</code></pre>
<p>这里定义了一个 DemoService 服务，服务只包含一个 sayHello 方法，同时定义了方法的入参和出参。</p>
<h4>2. Compiler 编译服务</h4>
<ol>
<li>引入 Protobuf Compiler Maven 插件，同时指定 <code>protoc-gen-dubbo-java</code> RPC 扩展</li>
</ol>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.7.1:exe:${os.detected.classifier}	
    <span class="hljs-tag">&lt;/<span class="hljs-name">protocArtifact</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pluginId</span>&gt;</span>dubbo-grpc-java<span class="hljs-tag">&lt;/<span class="hljs-name">pluginId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pluginArtifact</span>&gt;</span>org.apache.dubbo:protoc-gen-dubbo-java:1.19.0-SNAPSHOT:exe:${os.detected.classifier}<span class="hljs-tag">&lt;/<span class="hljs-name">pluginArtifact</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>&gt;</span>build/generated/source/proto/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">outputDirectory</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">clearOutputDirectory</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">clearOutputDirectory</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pluginParameter</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">pluginParameter</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile-custom<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
</code></pre>
<p>注意，这里与 <a href="https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-grpc">Dubbo 对 gRPC</a> 支持部分的区别在于：
<code>&lt;pluginParameter&gt;dubbo&lt;/pluginParameter&gt;</code></p>
<ol start="2">
<li>
<p>生成 Dubbo stub</p>
<pre><code class="language-shell"><span class="hljs-meta">#</span><span class="bash"> 运行以下 maven 命令</span>
<span class="hljs-meta">$</span><span class="bash">mvn clean compile</span>
</code></pre>
<p>生成的 Java 类如下：</p>
<p><img src="../../img/blog/grpc/compiler-protobuf.png" alt="image-20191028201240976"></p>
<p>DemoServiceDubbo 为 Dubbo 定制的 stub</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServiceDubbo</span> </span>{

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicBoolean registered = <span class="hljs-keyword">new</span> AtomicBoolean();

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Class&lt;?&gt; init() {
      Class&lt;?&gt; clazz = <span class="hljs-keyword">null</span>;
      <span class="hljs-keyword">try</span> {
          clazz = Class.forName(DemoServiceDubbo<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>())</span>;
          <span class="hljs-keyword">if</span> (registered.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) {
              org.apache.dubbo.common.serialize.protobuf.support.ProtobufUtils.marshaller(
                  org.apache.dubbo.demo.HelloRequest.getDefaultInstance());
              org.apache.dubbo.common.serialize.protobuf.support.ProtobufUtils.marshaller(
                  org.apache.dubbo.demo.HelloReply.getDefaultInstance());
          }
       } <span class="hljs-keyword">catch</span> (ClassNotFoundException e) {
          <span class="hljs-comment">// ignore </span>
       }
       <span class="hljs-keyword">return</span> clazz;
  }

  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">DemoServiceDubbo</span><span class="hljs-params">()</span> </span>{}

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SERVICE_NAME = <span class="hljs-string">"demoservice.DemoService"</span>;

  <span class="hljs-comment">/**
   * Code generated for Dubbo
   */</span>
  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IDemoService</span> </span>{

     <span class="hljs-keyword">static</span> Class&lt;?&gt; clazz = init();
     org.apache.dubbo.demo.<span class="hljs-function">HelloReply <span class="hljs-title">sayHello</span><span class="hljs-params">(org.apache.dubbo.demo.HelloRequest request)</span></span>;

     java.util.concurrent.CompletableFuture&lt;org.apache.dubbo.demo.HelloReply&gt; sayHelloAsync(
  org.apache.dubbo.demo.HelloRequest request);

 }

}
</code></pre>
<p>最值得注意的是 <code>IDemoService</code> 接口，它会作为 Dubbo 服务定义基础接口。</p>
</li>
</ol>
<h4>3. 开发业务逻辑</h4>
<p>从这一步开始，所有开发流程就和直接定义 Java 接口一样了。实现接口定义业务逻辑。</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DemoServiceDubbo</span>.<span class="hljs-title">IDemoService</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(DemoServiceImpl<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> HelloReply <span class="hljs-title">sayHello</span><span class="hljs-params">(HelloRequest request)</span> </span>{
        logger.info(<span class="hljs-string">"Hello "</span> + request.getName() + <span class="hljs-string">", request from consumer: "</span> + RpcContext.getContext().getRemoteAddress());
        <span class="hljs-keyword">return</span> HelloReply.newBuilder()
                .setMessage(<span class="hljs-string">"Hello "</span> + request.getName() + <span class="hljs-string">", response from provider: "</span>
                        + RpcContext.getContext().getLocalAddress())
                .build();
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> CompletableFuture&lt;HelloReply&gt; <span class="hljs-title">sayHelloAsync</span><span class="hljs-params">(HelloRequest request)</span> </span>{
        <span class="hljs-keyword">return</span> CompletableFuture.completedFuture(sayHello(request));
    }
}
</code></pre>
<h4>4. 配置 Provider</h4>
<p>暴露 Dubbo 服务</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"demo-provider"</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dubbo"</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demoService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.dubbo.demo.provider.DemoServiceImpl"</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"org.apache.dubbo.demo.DemoServiceDubbo$IDemoService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"demoService"</span>/&gt;</span>

</code></pre>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{
  ClassPathXmlApplicationContext context = 
    <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"spring/dubbo-provider.xml"</span>);
  context.start();
  System.in.read();
}
</code></pre>
<h4>5. 配置 Consumer</h4>
<p>引用 Dubbo 服务</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"demo-consumer"</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demoService"</span> <span class="hljs-attr">check</span>=<span class="hljs-string">"false"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"org.apache.dubbo.demo.DemoServiceDubbo$IDemoService"</span>/&gt;</span>
</code></pre>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{
  ClassPathXmlApplicationContext context = 
    <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"spring/dubbo-consumer.xml"</span>);
  context.start();
  IDemoService demoService = context.getBean(<span class="hljs-string">"demoService"</span>, IDemoService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
  HelloRequest request = HelloRequest.newBuilder().setName(<span class="hljs-string">"Hello"</span>).build();
  HelloReply reply = demoService.sayHello(request);
  System.out.println(<span class="hljs-string">"result: "</span> + reply.getMessage());
  System.in.read();
}
</code></pre>
</section><footer class="footer-container"><div class="footer-body"><img src="/img/dubbo_gray.png"/><img class="apache" src="/img/apache_logo.png"/><div class="cols-container"><div class="col col-12"><h3></h3><p></p></div><div class="col col-4"><dl><dt>ASF</dt><dd><a href="http://www.apache.org" target="_self">基金会</a></dd><dd><a href="http://www.apache.org/licenses/" target="_self">证书</a></dd><dd><a href="http://www.apache.org/events/current-event" target="_self">事件</a></dd><dd><a href="http://www.apache.org/foundation/sponsorship.html" target="_self">赞助</a></dd><dd><a href="http://www.apache.org/foundation/thanks.html" target="_self">致谢</a></dd></dl></div><div class="col col-4"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/user/quick-start.html" target="_self">快速开始</a></dd><dd><a href="/zh-cn/docs/dev/build.html" target="_self">开发者指南</a></dd><dd><a href="/zh-cn/docs/admin/ops/dubbo-ops.html" target="_self">运维管理</a></dd><dd><a href="https://github.com/apache/dubbo-website/issues/new" target="_self">报告文档问题</a></dd><dd><a href="https://github.com/apache/dubbo-website" target="_self">编辑此文档</a></dd></dl></div><div class="col col-4"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/community/index.html" target="_self">社区</a></dd><dd><a href="https://www.apache.org/security" target="_self">安全</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2018-2019 The Apache Software Foundation. Apache and the Apache feather logo are trademarks of The Apache Software Foundation.</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
  <script src="/build/blogDetail.js"></script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112489517-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-112489517-1');
	</script>
</body>
</html>