{
  "filename": "Dubbo-supporting-gRPC-HTTP2-and-protobuf.md",
  "__html": "<h1>Dubbo 在跨语言和协议穿透性方向上的探索：支持 HTTP/2 gRPC 和 Protobuf</h1>\n<p>本文整理自刘军在 Dubbo 成都 meetup 上分享的《Dubbo 在多语言和协议穿透性方向上的探索》。</p>\n<p>本文总体上可分为基础产品简介、Dubbo 对 gRPC (HTTP/2) 和 Protobuf 的支持及示例演示三部分，在简介部分介绍了 Dubbo、HTTP/2、gRPC、Protobuf 的基本概念和特点；第二部分介绍了 Dubbo 为何要支持 gRPC (HTTP/2) 和 Protobuf，以及这种支持为 gRPC 和 Dubbo 开发带来的好处与不同；第三部分通过两个实例分别演示了 Dubbo gRPC 和 Dubbo Protobuf 的使用方式。</p>\n<h2>基本介绍</h2>\n<h3>Dubbo 协议</h3>\n<p>从协议层面展开，以下是当前 2.7 版本支持的 Dubbo 协议</p>\n<p><img src=\"img/blog/grpc/dubbo-ptotocol.png\" alt=\"image-20191029103919557\"></p>\n<p>众所周知，Dubbo 协议是直接定义在 TCP 传输层协议之上，由于 TCP 高可靠全双工的特点，为 Dubbo 协议的定义提供了最大的灵活性，但同时也正是因为这样的灵活性，RPC 协议普遍都是定制化的私有协议，Dubbo 同样也面临这个问题。在这里我们着重讲一下 Dubbo 在协议通用性方面值得改进的地方，关于协议详细解析请参见<a href=\"http://dubbo.apache.org/zh-cn/blog/dubbo-protocol.html\">官网博客</a></p>\n<ul>\n<li>Dubbo 协议体 Body 中有一个可扩展的 attachments 部分，这给 RPC 方法之外额外传递附加属性提供了可能，是一个很好的设计。但是类似的 Header 部分，却缺少类似的可扩展 attachments，这点可参考 HTTP 定义的 Ascii Header 设计，将 Body Attachments 和 Header Attachments 做职责划分。</li>\n<li>Body 协议体中的一些 RPC 请求定位符如 Service Name、Method Name、Version 等，可以提到 Header 中，和具体的序列化协议解耦，以更好的被网络基础设施识别或用于流量管控。</li>\n<li>扩展性不够好，欠缺协议升级方面的设计，如 Header 头中没有预留的状态标识位，或者像 HTTP 有专为协议升级或协商设计的特殊 packet。</li>\n<li>在 Java 版本的代码实现上，不够精简和通用。如在链路传输中，存在一些语言绑定的内容；消息体中存在冗余内容，如 Service Name 在 Body 和 Attachments 中都存在。</li>\n</ul>\n<h3>HTTP/1</h3>\n<p>相比于直接构建与 TPC 传输层的私有 RPC 协议，构建于 HTTP 之上的远程调用解决方案会有更好的通用性，如WebServices 或 REST 架构，使用 HTTP + JSON 可以说是一个事实标准的解决方案。</p>\n<p>之所有选择构建在 HTTP 之上，我认为有两个最大的优势：</p>\n<ol>\n<li>HTTP 的语义和可扩展性能很好的满足 RPC 调用需求。</li>\n<li>通用性，HTTP 协议几乎被网络上的所有设备所支持，具有很好的协议穿透性。</li>\n</ol>\n<p><img src=\"../../img/blog/grpc/http1.png\" alt=\"image-20191029113404906\"></p>\n<p>具体来说，HTTP/1 的优势和限制是：</p>\n<ul>\n<li>\n<p>典型的 Request – Response 模型，一个链路上一次只能有一个等待的 Request 请求</p>\n</li>\n<li>\n<p>HTTP/1 支持 Keep-Alive 链接，避免了链接重复创建开销</p>\n</li>\n<li>\n<p>Human Readable Headers，使用更通用、更易于人类阅读的头部传输格式</p>\n</li>\n<li>\n<p>无直接 Server Push 支持，需要使用 Polling Long-Polling 等变通模式</p>\n</li>\n</ul>\n<h3>HTTP/2</h3>\n<p>HTTP/2 保留了 HTTP/1 的所有语义，在保持兼容的同时，在通信模型和传输效率上做了很大的改进。</p>\n<p><img src=\"../../img/blog/grpc/http2.png\" alt=\"image-20191029113416731\"></p>\n<ul>\n<li>\n<p>支持单条链路上的 Multiplexing，相比于 Request - Response 独占链路，基于 Frame 实现更高效利用链路</p>\n</li>\n<li>\n<p>Request - Stream 语义，原生支持 Server Push 和 Stream 数据传输</p>\n</li>\n<li>\n<p>Flow Control，单条 Stream 粒度的和整个链路粒度的流量控制</p>\n</li>\n<li>\n<p>头部压缩 HPACK</p>\n</li>\n<li>\n<p>Binary Frame</p>\n</li>\n<li>\n<p>原生 TLS 支持</p>\n</li>\n</ul>\n<h3>gRPC</h3>\n<p>上面提到了在 HTTP 及 TCP 协议之上构建 RPC 协议各自的优缺点，相比于 Dubbo 构建于 TPC 传输层之上，Google 选择将 gRPC 直接定义在 HTTP/2 协议之上，关于 gRPC 的 [基本介绍](<a href=\"https://platformlab.stanford.edu/Seminar\">https://platformlab.stanford.edu/Seminar</a> Talks/gRPC.pdf)和 <a href=\"https://grpc.io/blog/principles/?spm=ata.13261165.0.0.2be55017XbUhs8\">设计愿景</a> 请参考以上两篇文章，我这里仅摘取 设计愿景 中几个能反映 gRPC 设计目的特性来做简单说明。</p>\n<ul>\n<li>\n<p>Coverage &amp; Simplicity，协议设计和框架实现要足够通用和简单，能运行在任何设备之上，甚至一些资源首先的如 IoT、Mobile 等设备。</p>\n</li>\n<li>\n<p>Interoperability &amp; Reach，要构建在更通用的协议之上，协议本身要能被网络上几乎所有的基础设施所支持。</p>\n</li>\n<li>\n<p>General Purpose &amp; Performant，要在场景和性能间做好平衡，首先协议本身要是适用于各种场景的，同时也要尽量有高的性能。</p>\n</li>\n<li>\n<p>Payload Agnostic，协议上传输的负载要保持语言和平台中立。</p>\n</li>\n<li>\n<p>Streaming，要支持 Request - Response、Request - Stream、Bi-Steam 等通信模型。</p>\n</li>\n<li>\n<p>Flow Control，协议自身具备流量感知和限制的能力。</p>\n</li>\n<li>\n<p>Metadata Exchange，在 RPC 服务定义之外，提供额外附加数据传输的能力。</p>\n</li>\n</ul>\n<p>总的来说，在这样的设计理念指导下，gRPC 最终被设计为一个跨语言、跨平台的、通用的、高性能的、基于 HTTP/2 的 RPC 协议和框架。</p>\n<h3>Protobuf</h3>\n<p><a href=\"https://developers.google.com/protocol-buffers/docs/overview\">Protocol buffers (Protobuf)</a> 是 Google 推出的一个跨平台、语言中立的结构化数据描述和序列化的产品，它定义了一套结构化数据定义的协议，同时也提供了相应的 <a href=\"https://github.com/protocolbuffers/protobuf/releases/tag/v3.10.0\">Compiler</a> 工具，用来将语言中立的描述转化为相应语言的具体描述。</p>\n<p>它的一些特性包括：</p>\n<ul>\n<li>\n<p>跨语言 跨平台，语言中立的数据描述格式，默认提供了生成多种语言的 Compiler 工具。</p>\n</li>\n<li>\n<p>安全性，由于反序列化的范围和输出内容格式都是 Compiler 在编译时预生成的，因此绕过了类似 Java Deserialization Vulnarability 的问题。</p>\n</li>\n<li>\n<p>二进制 高性能</p>\n</li>\n<li>\n<p>强类型</p>\n</li>\n<li>\n<p>字段变更向后兼容</p>\n</li>\n</ul>\n<pre><code class=\"language-idl\">message Person {\n  required string name = 1;\n  required int32 id = 2;\n  optional string email = 3;\n\n  enum PhoneType {\n    MOBILE = 0;\n    HOME = 1;\n    WORK = 2;\n  }\n\n  message PhoneNumber {\n    required string number = 1;\n    optional PhoneType type = 2 [default = HOME];\n  }\n\n  repeated PhoneNumber phone = 4;\n}\n</code></pre>\n<p>除了结构化数据描述之外，Protobuf 还支持定义 RPC 服务，它允许我们定义一个 <code>.proto</code> 的服务描述文件，进而利用 Protobuf Compiler 工具生成特定语言和 RPC 框架的接口和 stub。后续将要具体讲到的 gRPC + Protobuf、Dubbo-gRPC + Protobuf 以及 Dubbo + Protobuf 都是通过定制 Compiler 类实现的。</p>\n<pre><code class=\"language-idl\">service SearchService {\n rpc Search (SearchRequest) returns (SearchResponse);\n}\n</code></pre>\n<h2>Dubbo 所做的支持</h2>\n<p>跨语言的服务开发涉及到多个方面，从服务定义、RPC 协议到序列化协议都要做到语言中立，同时还针对每种语言有对应的 SDK 实现。虽然得益于社区的贡献，现在 Dubbo 在多语言 SDK 实现上逐步有了起色，已经提供了包括 Java, Go, PHP, C#, Python, NodeJs, C 等版本的客户端或全量实现版本，但在以上提到的跨语言友好型方面，以上三点还是有很多可改进之处。</p>\n<ul>\n<li>\n<p>协议，上面我们已经分析过 Dubbo 协议既有的缺点，如果能在 HTTP/2 之上构建应用层协议，则无疑能避免这些弊端，同时最大可能的提高协议的穿透性，避免网关等协议转换组件的存在，更有利于链路上的流量管控。考虑到 gRPC 是构建在 HTTP/2 之上，并且已经是云原生领域推荐的通信协议，Dubbo 在第一阶段选择了直接支持 gRPC 协议作为当前的 HTTP/2 解决方案。我们也知道 gRPC 框架自身的弊端在于易用性不足以及服务治理能力欠缺（这也是目前绝大多数厂商不会直接裸用 gRPC 框架的原因），通过将其集成进 Dubbo 框架，用户可以方便的使用 Dubbo 编程模型 + Dubbo 服务治理 + gRPC 协议通信的组合。</p>\n</li>\n<li>\n<p>服务定义，当前 Dubbo 的服务定义和具体的编程语言绑定，没有提供一种语言中立的服务描述格式，比如 Java 就是定义 Interface 接口，到了其他语言又得重新以另外的格式定义一遍。因此 Dubbo 通过支持 Protobuf 实现了语言中立的服务定义。</p>\n</li>\n<li>\n<p>序列化，Dubbo 当前支持的序列化包括 Json、Hessian2、Kryo、FST、Java 等，而这其中支持跨语言的只有 Json、Hessian2，通用的 Json 有固有的性能问题，而 Hessian2 无论在效率还是多语言 SDK 方面都有所欠缺。为此，Dubbo 通过支持 Protobuf 序列化来提供更高效、易用的跨语言序列化方案。</p>\n</li>\n</ul>\n<h2>示例</h2>\n<h3>示例 1，使用 Dubbo 开发 gRPC 服务</h3>\n<p><a href=\"https://grpc.io/\">gRPC</a> 是 Google 开源的构建在 HTTP/2 之上的一个 PRC 通信协议。Dubbo 依赖其灵活的协议扩展机制，增加了对 gRPC (HTTP/2) 协议的支持。</p>\n<p>目前的支持限定在 Dubbo Java 语言版本，后续 Go 语言或其他语言版本将会以类似方式提供支持。下面，通过一个<a href=\"https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-grpc\">简单的示例</a>来演示如何在 Dubbo 中使用 gRPC 协议通信。</p>\n<h4>1. 定义服务 IDL</h4>\n<p>首先，通过标准的 Protobuf 协议定义服务如下：</p>\n<pre><code class=\"language-idl\">syntax = &quot;proto3&quot;;\n\noption java_multiple_files = true;\noption java_package = &quot;io.grpc.examples.helloworld&quot;;\noption java_outer_classname = &quot;HelloWorldProto&quot;;\noption objc_class_prefix = &quot;HLW&quot;;\n\npackage helloworld;\n\n// The greeting service definition.\nservice Greeter {\n  // Sends a greeting\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n\n// The request message containing the user's name.\nmessage HelloRequest {\n  string name = 1;\n}\n\n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n\n</code></pre>\n<p>在此，我们定义了一个只有一个方法 sayHello 的 Greeter 服务，同时定义了方法的入参和出参，</p>\n<h4>2. PCompiler 生成 Stub</h4>\n<ol>\n<li>定义 Maven Protobuf Compiler 插件工具。这里我们扩展了 Protobuf 的 Compiler 工具，以用来生成 Dubbo 特有的 RPC stub，此当前以 Maven 插件的形式发布。</li>\n</ol>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>protobuf-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.5.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.7.1:exe:${os.detected.classifier}\t\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">protocArtifact</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">pluginId</span>&gt;</span>dubbo-grpc-java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">pluginId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">pluginArtifact</span>&gt;</span>org.apache.dubbo:protoc-gen-dubbo-java:1.19.0-SNAPSHOT:exe:${os.detected.classifier}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">pluginArtifact</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">outputDirectory</span>&gt;</span>build/generated/source/proto/main/java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">outputDirectory</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clearOutputDirectory</span>&gt;</span>false<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clearOutputDirectory</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">pluginParameter</span>&gt;</span>grpc<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">pluginParameter</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">configuration</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">executions</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">execution</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">goals</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">goal</span>&gt;</span>compile<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">goal</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">goal</span>&gt;</span>compile-custom<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">goal</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">goals</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">execution</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">executions</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n</code></pre>\n<p>其中，</p>\n<p>pluginArtifact 指定了 Dubbo 定制版本的 Java Protobuf Compiler 插件，通过这个插件来在编译过程中生成 Dubbo 定制版本的 gRPC stub。</p>\n<pre><code class=\"language-xml\"> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">pluginArtifact</span>&gt;</span>org.apache.dubbo:protoc-gen-dubbo-java:1.19.0-SNAPSHOT:exe:${os.detected.classifier}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">pluginArtifact</span>&gt;</span>\n</code></pre>\n<p>由于 <code>protoc-gen-dubbo-java</code> 支持 gRPC 和 Dubbo 两种协议，可生成的 stub 类型，默认值是 gRPC，关于 dubbo 协议的使用可参见 <a href=\"\">使用 Protobuf 开发 Dubbo 服务</a>。</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">pluginParameter</span>&gt;</span>grpc<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">pluginParameter</span>&gt;</span>\n</code></pre>\n<ol start=\"2\">\n<li>\n<p>生成 Java Bean 和 Dubbo-gRPC stub</p>\n<pre><code class=\"language-sh\"><span class=\"hljs-comment\"># 运行以下 maven 命令</span>\n$ mvn clean compile\n</code></pre>\n<p>生成的 Stub 和消息类 如下：\n<img src=\"../../img/blog/grpc/compiler-classes.png\" alt=\"image-20191026130516896\"></p>\n<p>重点关注 GreeterGrpc ，包含了所有 gRPC 标准的 stub 类/方法，同时增加了 Dubbo 特定的接口，之后 Provider 端的服务暴露和 Consumer 端的服务调用都将依赖这个接口。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/**\n * Code generated for Dubbo\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">IGreeter</span> </span>{\n\n<span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">public</span> io.grpc.examples.helloworld.<span class=\"hljs-function\">HelloReply \t<span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(io.grpc.examples.helloworld.HelloRequest request)</span> </span>{\n   <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnsupportedOperationException(<span class=\"hljs-string\">\"No need to override this method, extend XxxImplBase and override all methods it allows.\"</span>);\n}\n\n<span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">public</span> com.google.common.util.concurrent.ListenableFuture&lt;io.grpc.examples.helloworld.HelloReply&gt; sayHelloAsync(\n    io.grpc.examples.helloworld.HelloRequest request) {\n   <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UnsupportedOperationException(<span class=\"hljs-string\">\"No need to override this method, extend XxxImplBase and override all methods it allows.\"</span>);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(io.grpc.examples.helloworld.HelloRequest request,\n    io.grpc.stub.StreamObserver&lt;io.grpc.examples.helloworld.HelloReply&gt; responseObserver)</span></span>;\n\n}\n</code></pre>\n</li>\n</ol>\n<h4>3. 业务逻辑开发</h4>\n<p>继承 <code>GreeterGrpc.GreeterImplBase</code> （来自第 2 步），编写业务逻辑，这点和原生 gRPC 是一致的。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> org.apache.dubbo.samples.basic.impl;\n\n<span class=\"hljs-keyword\">import</span> io.grpc.examples.helloworld.GreeterGrpc;\n<span class=\"hljs-keyword\">import</span> io.grpc.examples.helloworld.HelloReply;\n<span class=\"hljs-keyword\">import</span> io.grpc.examples.helloworld.HelloRequest;\n<span class=\"hljs-keyword\">import</span> io.grpc.stub.StreamObserver;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GrpcGreeterImpl</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">GreeterGrpc</span>.<span class=\"hljs-title\">GreeterImplBase</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver)</span> \t\t</span>{\n        System.out.println(<span class=\"hljs-string\">\"Received request from client.\"</span>);\n        System.out.println(<span class=\"hljs-string\">\"Executing thread is \"</span> + Thread.currentThread().getName());\n        HelloReply reply = HelloReply.newBuilder()\n          .setMessage(<span class=\"hljs-string\">\"Hello \"</span> + \trequest.getName()).build();\n        responseObserver.onNext(reply);\n        responseObserver.onCompleted();\n    }\n}\n</code></pre>\n<h4>4. Provider 端暴露 Dubbo 服务</h4>\n<p>以 Spring XML 为例</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:application</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"demo-provider\"</span>/&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 指定服务暴露协议为 gRPC --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"grpc\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"grpc\"</span>/&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:registry</span> <span class=\"hljs-attr\">address</span>=<span class=\"hljs-string\">\"zookeeper://${zookeeper.address:127.0.0.1}:2181\"</span>/&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"greeter\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.apache.dubbo.samples.basic.impl.GrpcGreeterImpl\"</span>/&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 指定 protoc-gen-dubbo-java 生成的接口 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"io.grpc.examples.helloworld.GreeterGrpc$IGreeter\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"greeter\"</span> <span class=\"hljs-attr\">protocol</span>=<span class=\"hljs-string\">\"grpc\"</span>/&gt;</span>\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n  ClassPathXmlApplicationContext context =\n    <span class=\"hljs-keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"hljs-string\">\"spring/dubbo-demo-provider.xml\"</span>);\n  context.start();\n\n  System.out.println(<span class=\"hljs-string\">\"dubbo service started\"</span>);\n  <span class=\"hljs-keyword\">new</span> CountDownLatch(<span class=\"hljs-number\">1</span>).await();\n}\n</code></pre>\n<h4>5. 引用 Dubbo 服务</h4>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:application</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"demo-consumer\"</span>/&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:registry</span> <span class=\"hljs-attr\">address</span>=<span class=\"hljs-string\">\"zookeeper://${zookeeper.address:127.0.0.1}:2181\"</span>/&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 指定 protoc-gen-dubbo-java 生成的接口 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"greeter\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"io.grpc.examples.helloworld.GreeterGrpc$IGreeter\"</span> <span class=\"hljs-attr\">protocol</span>=<span class=\"hljs-string\">\"grpc\"</span>/&gt;</span>\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n  ClassPathXmlApplicationContext context =\n    <span class=\"hljs-keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"hljs-string\">\"spring/dubbo-demo-consumer.xml\"</span>);\n  context.start();\n\n  GreeterGrpc.IGreeter greeter = (GreeterGrpc.IGreeter) context.getBean(<span class=\"hljs-string\">\"greeter\"</span>);\n\n  HelloReply reply = greeter.sayHello(HelloRequest.newBuilder().setName(<span class=\"hljs-string\">\"world!\"</span>).build());\n  System.out.println(<span class=\"hljs-string\">\"Result: \"</span> + reply.getMessage());\n\n  System.in.read();\n}\n</code></pre>\n<h4>示例1附：高级用法</h4>\n<p><strong>一、异步调用</strong></p>\n<p>再来看一遍 <code>protoc-gen-dubbo-java</code> 生成的接口：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/**\n * Code generated for Dubbo\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">IGreeter</span> </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">public</span> HelloReply <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(HelloRequest request)</span> </span>{\n     <span class=\"hljs-comment\">// ......</span>\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">public</span> ListenableFuture&lt;HelloReply&gt; <span class=\"hljs-title\">sayHelloAsync</span><span class=\"hljs-params\">(HelloRequest request)</span> </span>{\n     <span class=\"hljs-comment\">// ......</span>\n  }\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver)</span></span>;\n}\n</code></pre>\n<p>这里为 sayHello 方法生成了三种类型的重载方法，分别用于同步调用、异步调用和流式调用，如果消费端要进行异步调用，直接调用 sayHelloAsync() 即可：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n\t<span class=\"hljs-comment\">// ...</span>\n  GreeterGrpc.IGreeter greeter = (GreeterGrpc.IGreeter) context.getBean(<span class=\"hljs-string\">\"greeter\"</span>);\n  ListenableFuture&lt;HelloReply&gt; future =   \n        greeter.sayHAsyncello(HelloRequest.newBuilder().setName(<span class=\"hljs-string\">\"world!\"</span>).build());\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p><strong>二、高级配置</strong></p>\n<p>由于当前实现方式是直接集成了 gRPC-java SDK，因此很多配置还没有和 Dubbo 侧对齐，或者还没有以 Dubbo 的配置形式开放，因此，为了提供最大的灵活性，我们直接把 gRPC-java 的配置接口暴露了出来。</p>\n<p>绝大多数场景下，你可能并不会用到以下扩展，因为它们更多的是对 gRPC 协议的拦截或者 HTTP/2 层面的配置。同时使用这些扩展点可能需要对 HTTP/2 或 gRPC 有基本的了解。</p>\n<p><strong>扩展点</strong></p>\n<p>目前支持的扩展点如下：</p>\n<ul>\n<li>\n<p>org.apache.dubbo.rpc.protocol.grpc.interceptors.ClientInterceptor</p>\n</li>\n<li>\n<p>org.apache.dubbo.rpc.protocol.grpc.interceptors.GrpcConfigurator</p>\n</li>\n<li>\n<p>org.apache.dubbo.rpc.protocol.grpc.interceptors.ServerInterceptor</p>\n</li>\n<li>\n<p>org.apache.dubbo.rpc.protocol.grpc.interceptors.ServerTransportFilter</p>\n</li>\n</ul>\n<p>GrpcConfigurator 是最通用的扩展点，我们以此为例来说明一下，其基本定义如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">GrpcConfigurator</span> </span>{\n    <span class=\"hljs-comment\">// 用来定制 gRPC NettyServerBuilder</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">default</span> NettyServerBuilder <span class=\"hljs-title\">configureServerBuilder</span><span class=\"hljs-params\">(NettyServerBuilder builder, URL url)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> builder;\n    }\n    <span class=\"hljs-comment\">// 用来定制 gRPC NettyChannelBuilder</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">default</span> NettyChannelBuilder <span class=\"hljs-title\">configureChannelBuilder</span><span class=\"hljs-params\">(NettyChannelBuilder builder, URL url)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> builder;\n    }\n    <span class=\"hljs-comment\">// 用来定制 gRPC CallOptions, 定义某个服务在每次请求间传递数据</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">default</span> CallOptions <span class=\"hljs-title\">configureCallOptions</span><span class=\"hljs-params\">(CallOptions options, URL url)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> options;\n    }\n}\n</code></pre>\n<p>以下是一个示例扩展实现：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyGrpcConfigurator</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">GrpcConfigurator</span> </span>{\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ExecutorService executor = Executors\n            .newFixedThreadPool(<span class=\"hljs-number\">200</span>, <span class=\"hljs-keyword\">new</span> NamedThreadFactory(<span class=\"hljs-string\">\"Customized-grpc\"</span>, <span class=\"hljs-keyword\">true</span>));\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> NettyServerBuilder <span class=\"hljs-title\">configureServerBuilder</span><span class=\"hljs-params\">(NettyServerBuilder builder, URL url)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> builder.executor(executor);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> NettyChannelBuilder <span class=\"hljs-title\">configureChannelBuilder</span><span class=\"hljs-params\">(NettyChannelBuilder builder, URL url)</span>\n    </span>{\n        <span class=\"hljs-keyword\">return</span> builder.flowControlWindow(<span class=\"hljs-number\">10</span>);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> CallOptions <span class=\"hljs-title\">configureCallOptions</span><span class=\"hljs-params\">(CallOptions options, URL url)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> options.withOption(CallOptions.Key.create(<span class=\"hljs-string\">\"key\"</span>), <span class=\"hljs-string\">\"value\"</span>);\n    }\n}\n\n</code></pre>\n<p>配置为 Dubbo SPI，`resources/META-INF/services 增加配置文件</p>\n<pre><code class=\"language-properties\"><span class=\"hljs-attr\">default</span>=<span class=\"hljs-string\">org.apache.dubbo.samples.basic.comtomize.MyGrpcConfigurator</span>\n</code></pre>\n<ol>\n<li>\n<p>指定 Provider 端线程池</p>\n<p>默认用的是 Dubbo 的线程池，有 fixed (默认)、cached、direct 等类型。以下演示了切换为业务自定义线程池。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ExecutorService executor = Executors\n      .newFixedThreadPool(<span class=\"hljs-number\">200</span>, <span class=\"hljs-keyword\">new</span> NamedThreadFactory(<span class=\"hljs-string\">\"Customized-grpc\"</span>, <span class=\"hljs-keyword\">true</span>));\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> NettyServerBuilder <span class=\"hljs-title\">configureServerBuilder</span><span class=\"hljs-params\">(NettyServerBuilder builder, URL url)</span> \n</span>{\n  <span class=\"hljs-keyword\">return</span> builder.executor(executor);\n}\n\n</code></pre>\n</li>\n<li>\n<p>指定 Consumer 端限流值</p>\n<p>设置 Consumer 限流值为 10</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> NettyChannelBuilder <span class=\"hljs-title\">configureChannelBuilder</span><span class=\"hljs-params\">(NettyChannelBuilder builder, URL url)</span>\n</span>{\n  <span class=\"hljs-keyword\">return</span> builder.flowControlWindow(<span class=\"hljs-number\">10</span>);\n}\n\n</code></pre>\n</li>\n<li>\n<p>传递附加参数</p>\n<p>DemoService 服务调用传递 key</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> CallOptions <span class=\"hljs-title\">configureCallOptions</span><span class=\"hljs-params\">(CallOptions options, URL url)</span> </span>{\n  <span class=\"hljs-keyword\">if</span> (url.getServiceInterface().equals(<span class=\"hljs-string\">\"xxx.DemoService\"</span>)) {\n    <span class=\"hljs-keyword\">return</span> options.withOption(CallOptions.Key.create(<span class=\"hljs-string\">\"key\"</span>), <span class=\"hljs-string\">\"value\"</span>);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> options;\n  }\n}\n\n</code></pre>\n</li>\n</ol>\n<p><strong>三、TLS 配置</strong></p>\n<p>配置方式和 Dubbo 提供的通用的 <a href=\"\">TLS 支持</a>一致，具体请参见文档</p>\n<h3>示例 2， 使用 Protobuf 开发 Dubbo 服务</h3>\n<p>下面，我们以一个<a href=\"https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-protobuf\">具体的示例</a>来看一下基于 Protobuf 的 Dubbo 服务开发流程。</p>\n<h4>1. 定义服务</h4>\n<p>通过标准 Protobuf 定义服务</p>\n<pre><code class=\"language-idl\">syntax = &quot;proto3&quot;;\n\noption java_multiple_files = true;\noption java_package = &quot;org.apache.dubbo.demo&quot;;\noption java_outer_classname = &quot;DemoServiceProto&quot;;\noption objc_class_prefix = &quot;DEMOSRV&quot;;\n\npackage demoservice;\n\n// The demo service definition.\nservice DemoService {\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n\n// The request message containing the user's name.\nmessage HelloRequest {\n  string name = 1;\n}\n\n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n\n</code></pre>\n<p>这里定义了一个 DemoService 服务，服务只包含一个 sayHello 方法，同时定义了方法的入参和出参。</p>\n<h4>2. Compiler 编译服务</h4>\n<ol>\n<li>引入 Protobuf Compiler Maven 插件，同时指定 <code>protoc-gen-dubbo-java</code> RPC 扩展</li>\n</ol>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>protobuf-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>0.5.1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">configuration</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.7.1:exe:${os.detected.classifier}\t\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">protocArtifact</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">pluginId</span>&gt;</span>dubbo-grpc-java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">pluginId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">pluginArtifact</span>&gt;</span>org.apache.dubbo:protoc-gen-dubbo-java:1.19.0-SNAPSHOT:exe:${os.detected.classifier}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">pluginArtifact</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">outputDirectory</span>&gt;</span>build/generated/source/proto/main/java<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">outputDirectory</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clearOutputDirectory</span>&gt;</span>false<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clearOutputDirectory</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">pluginParameter</span>&gt;</span>dubbo<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">pluginParameter</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">configuration</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">executions</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">execution</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">goals</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">goal</span>&gt;</span>compile<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">goal</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">goal</span>&gt;</span>compile-custom<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">goal</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">goals</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">execution</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">executions</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n</code></pre>\n<p>注意，这里与 <a href=\"https://github.com/apache/dubbo-samples/tree/master/dubbo-samples-grpc\">Dubbo 对 gRPC</a> 支持部分的区别在于：\n<code>&lt;pluginParameter&gt;dubbo&lt;/pluginParameter&gt;</code></p>\n<ol start=\"2\">\n<li>\n<p>生成 Dubbo stub</p>\n<pre><code class=\"language-shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 运行以下 maven 命令</span>\n<span class=\"hljs-meta\">$</span><span class=\"bash\">mvn clean compile</span>\n</code></pre>\n<p>生成的 Java 类如下：</p>\n<p><img src=\"../../img/blog/grpc/compiler-protobuf.png\" alt=\"image-20191028201240976\"></p>\n<p>DemoServiceDubbo 为 Dubbo 定制的 stub</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoServiceDubbo</span> </span>{\n\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> AtomicBoolean registered = <span class=\"hljs-keyword\">new</span> AtomicBoolean();\n\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Class&lt;?&gt; init() {\n      Class&lt;?&gt; clazz = <span class=\"hljs-keyword\">null</span>;\n      <span class=\"hljs-keyword\">try</span> {\n          clazz = Class.forName(DemoServiceDubbo<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>.<span class=\"hljs-title\">getName</span>())</span>;\n          <span class=\"hljs-keyword\">if</span> (registered.compareAndSet(<span class=\"hljs-keyword\">false</span>, <span class=\"hljs-keyword\">true</span>)) {\n              org.apache.dubbo.common.serialize.protobuf.support.ProtobufUtils.marshaller(\n                  org.apache.dubbo.demo.HelloRequest.getDefaultInstance());\n              org.apache.dubbo.common.serialize.protobuf.support.ProtobufUtils.marshaller(\n                  org.apache.dubbo.demo.HelloReply.getDefaultInstance());\n          }\n       } <span class=\"hljs-keyword\">catch</span> (ClassNotFoundException e) {\n          <span class=\"hljs-comment\">// ignore </span>\n       }\n       <span class=\"hljs-keyword\">return</span> clazz;\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">DemoServiceDubbo</span><span class=\"hljs-params\">()</span> </span>{}\n\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String SERVICE_NAME = <span class=\"hljs-string\">\"demoservice.DemoService\"</span>;\n\n  <span class=\"hljs-comment\">/**\n   * Code generated for Dubbo\n   */</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">IDemoService</span> </span>{\n\n     <span class=\"hljs-keyword\">static</span> Class&lt;?&gt; clazz = init();\n     org.apache.dubbo.demo.<span class=\"hljs-function\">HelloReply <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(org.apache.dubbo.demo.HelloRequest request)</span></span>;\n\n     java.util.concurrent.CompletableFuture&lt;org.apache.dubbo.demo.HelloReply&gt; sayHelloAsync(\n  org.apache.dubbo.demo.HelloRequest request);\n\n }\n\n}\n</code></pre>\n<p>最值得注意的是 <code>IDemoService</code> 接口，它会作为 Dubbo 服务定义基础接口。</p>\n</li>\n</ol>\n<h4>3. 开发业务逻辑</h4>\n<p>从这一步开始，所有开发流程就和直接定义 Java 接口一样了。实现接口定义业务逻辑。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DemoServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">DemoServiceDubbo</span>.<span class=\"hljs-title\">IDemoService</span> </span>{\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Logger logger = LoggerFactory.getLogger(DemoServiceImpl<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> HelloReply <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(HelloRequest request)</span> </span>{\n        logger.info(<span class=\"hljs-string\">\"Hello \"</span> + request.getName() + <span class=\"hljs-string\">\", request from consumer: \"</span> + RpcContext.getContext().getRemoteAddress());\n        <span class=\"hljs-keyword\">return</span> HelloReply.newBuilder()\n                .setMessage(<span class=\"hljs-string\">\"Hello \"</span> + request.getName() + <span class=\"hljs-string\">\", response from provider: \"</span>\n                        + RpcContext.getContext().getLocalAddress())\n                .build();\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> CompletableFuture&lt;HelloReply&gt; <span class=\"hljs-title\">sayHelloAsync</span><span class=\"hljs-params\">(HelloRequest request)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> CompletableFuture.completedFuture(sayHello(request));\n    }\n}\n</code></pre>\n<h4>4. 配置 Provider</h4>\n<p>暴露 Dubbo 服务</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:application</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"demo-provider\"</span>/&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:registry</span> <span class=\"hljs-attr\">address</span>=<span class=\"hljs-string\">\"zookeeper://127.0.0.1:2181\"</span>/&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:protocol</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"dubbo\"</span>/&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bean</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.provider.DemoServiceImpl\"</span>/&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:service</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.DemoServiceDubbo$IDemoService\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"demoService\"</span>/&gt;</span>\n\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n  ClassPathXmlApplicationContext context = \n    <span class=\"hljs-keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"hljs-string\">\"spring/dubbo-provider.xml\"</span>);\n  context.start();\n  System.in.read();\n}\n</code></pre>\n<h4>5. 配置 Consumer</h4>\n<p>引用 Dubbo 服务</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:application</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"demo-consumer\"</span>/&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:registry</span> <span class=\"hljs-attr\">address</span>=<span class=\"hljs-string\">\"zookeeper://127.0.0.1:2181\"</span>/&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:reference</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demoService\"</span> <span class=\"hljs-attr\">check</span>=<span class=\"hljs-string\">\"false\"</span> <span class=\"hljs-attr\">interface</span>=<span class=\"hljs-string\">\"org.apache.dubbo.demo.DemoServiceDubbo$IDemoService\"</span>/&gt;</span>\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n  ClassPathXmlApplicationContext context = \n    <span class=\"hljs-keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"hljs-string\">\"spring/dubbo-consumer.xml\"</span>);\n  context.start();\n  IDemoService demoService = context.getBean(<span class=\"hljs-string\">\"demoService\"</span>, IDemoService<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n  HelloRequest request = HelloRequest.newBuilder().setName(<span class=\"hljs-string\">\"Hello\"</span>).build();\n  HelloReply reply = demoService.sayHello(request);\n  System.out.println(<span class=\"hljs-string\">\"result: \"</span> + reply.getMessage());\n  System.in.read();\n}\n</code></pre>\n",
  "link": "/zh-cn/blog/Dubbo-supporting-gRPC-HTTP2-and-protobuf.html",
  "meta": {}
}