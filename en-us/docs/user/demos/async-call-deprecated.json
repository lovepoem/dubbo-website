{
  "filename": "async-call-deprecated.md",
  "__html": "<pre><code># Asynchronous call\n\nNIO-based non-blocking parallel call, the client does not need to start multi-threading to complete multiple remote services in parallel, and the relative multi-threading overhead is small.。 [^1]\n\n![/user-guide/images/future.jpg](../sources/images/future.jpg)\n\nConfigured in consumer.xml:\n\n```xml\n&lt;dubbo:reference id=&quot;fooService&quot; interface=&quot;com.alibaba.foo.FooService&quot;&gt;\n      &lt;dubbo:method name=&quot;findFoo&quot; async=&quot;true&quot; /&gt;\n&lt;/dubbo:reference&gt;\n&lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.alibaba.bar.BarService&quot;&gt;\n      &lt;dubbo:method name=&quot;findBar&quot; async=&quot;true&quot; /&gt;\n&lt;/dubbo:reference&gt;\n</code></pre>\n<p>Call code:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// This call will return null immediately</span>\nfooService.findFoo(fooId);\n<span class=\"hljs-comment\">// Get the called Future reference, when the result is returned, it will be notified and set to this Future</span>\nFuture&lt;Foo&gt; fooFuture = RpcContext.getContext().getFuture();\n \n<span class=\"hljs-comment\">// This call will return null immediately</span>\nbarService.findBar(barId);\n<span class=\"hljs-comment\">// Get the called Future reference, when the result is returned, it will be notified and set to this Future</span>\nFuture&lt;Bar&gt; barFuture = RpcContext.getContext().getFuture();\n \n<span class=\"hljs-comment\">// At this time, the requests of findFoo and findBar are executed at the same time. The client does not need to start multi-threading to support parallelism, but completes the non-blocking of NIO.</span>\n \n/ / If foo has returned, get the <span class=\"hljs-keyword\">return</span> value directly, otherwise the thread waits, waiting <span class=\"hljs-keyword\">for</span> foo to <span class=\"hljs-keyword\">return</span>, the thread will be wake up by notify\nFoo foo = fooFuture.get();\n<span class=\"hljs-comment\">// Same as waiting for bar to return</span>\nBar bar = barFuture.get();\n \n<span class=\"hljs-comment\">// If foo needs 5 seconds to return, bar needs 6 seconds to return. In fact, it only takes 6 seconds to get foo and bar for the next processing.</span>\n</code></pre>\n<p>You can also set whether to wait for the message to be sent: <sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup></p>\n<ul>\n<li><code>sent=&quot;true&quot;</code> Wait for a message to be sent, and a message failure will throw an exception.</li>\n<li><code>sent=&quot;false&quot;</code> Do not wait for the message to be sent, put the message into the IO queue, and return immediately.</li>\n</ul>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"findFoo\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"true\"</span> <span class=\"hljs-attr\">sent</span>=<span class=\"hljs-string\">\"true\"</span> /&gt;</span>\n</code></pre>\n<p>If you just want to be asynchronous and completely ignore the return value, you can configure <code>return=&quot;false&quot;</code> to reduce the creation and management cost of the Future object:</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:method</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"findFoo\"</span> <span class=\"hljs-attr\">async</span>=<span class=\"hljs-string\">\"true\"</span> <span class=\"hljs-attr\">return</span>=<span class=\"hljs-string\">\"false\"</span> /&gt;</span>\n</code></pre>\n<pre><code></code></pre>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>Asynchronous always does not wait to return <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
  "link": "/en-us/docs/user/demos/async-call-deprecated.html",
  "meta": {}
}